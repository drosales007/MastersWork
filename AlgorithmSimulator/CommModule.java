/*
 * CommModule.java
 *
 * Created on November 2, 2003, 12:55 AM
 */

/**
 *
 * @author  Vinit
 */
import java.util.*;

public class CommModule {
    
    private Simulator sim;
    //public Gui gui;
    private Channel channel;    //private Linker linker;
    public Node  node[];
    public int num_nodes;
    public EventQueue eventQueue;
    public Vector msgQueue = new Vector ();
    public VectorClock clock[];
    public LamportClock lc[];
    private  int eventId =0;
    private int lastEventSentToGui =0;
    public ClassDetails classDetails[][];
    MainWindow  mainWindow;
    /** Creates a new instance of CommModule */
    
    // Variable for comm with gui 
    int selectedNode=0;
    List enabledNode = new ArrayList();
    public CommModule () {
        MyUtil.setCommModule (this);
    }
    
     public void init ( int _num_nodes, ClassDetails[][] _selectedClasses){
        //sim =s;
        num_nodes = _num_nodes;
        classDetails = _selectedClasses;
        eventQueue = new EventQueue();
        channel = new Channel(num_nodes, this);        
        node = new Node[num_nodes];
        clock = new VectorClock[num_nodes];
        for(int i =0; i< num_nodes; ++i)
            clock[i] = new VectorClock (num_nodes, i);
        lc = new LamportClock[num_nodes];
/* Vinit: 23 Feb 05: Why am I using LamportClocks
 *My guess : No reason , added vector clock later
 * TODO remove LamportClock if unecessary
 */  
        for(int i =0; i< num_nodes; ++i)
            lc[i] = new LamportClock ();       
        
   
        for(int i =0; i<num_nodes;i+=1){
            node[i] = new Node(i, classDetails);
            /**Enabled is false if node is to be diabled
             *eg: to simulate node failur
             **/
            enabledNode.add(new Boolean(true)); 
             //node[i].initNode(); Done in Node iteself
        }
        
        
    }
     
     
     //Remove this sometime .. make sure applet works after this is removed
     
//    public void init ( int _num_nodes, ConfigFileReader _selectedClass){
//        //sim =s;
//        num_nodes = _num_nodes;
//        eventQueue = new EventQueue();
//        channel = new Channel(num_nodes, this);        
//        node = new Node[num_nodes];
// //       eventQueue= new Vector(); //[num_nodes];
//        clock = new VectorClock[num_nodes];
//        for(int i =0; i< num_nodes; ++i)
//            clock[i] = new VectorClock (num_nodes, i);
//        lc = new LamportClock[num_nodes];
///* Vinit: 23 Feb 05: Why am I using LamportClocks
// *My guess : No reason , added vector clock later
// * TODO remove LamportClock if unecessary
// */  
//        for(int i =0; i< num_nodes; ++i)
//            lc[i] = new LamportClock ();
//
//        //Going to delete these 2 lines, no reason to do this in CommMudule
//        //Let commmodule directly accept classDetails
//        /*****************************/
//        ConfigFileReader newConfig = _selectedClass;
//        classDetails = newConfig.go(); 
//        
//        /*****************************/        
//        
//   
//        for(int i =0; i<num_nodes;i+=1){
//            node[i] = new Node(i, classDetails);
//            /**Enabled is false if node is to be diabled
//             *eg: to simulate node failur
//             **/
//            enabledNode.add(new Boolean(true)); 
//             //node[i].initNode(); Done in Node iteself
//        }
//        
//        
//    }
//    
    
    
    
    /**
     *Another init function
     *Sets appWindow in Comm to MainWindow generated by main Simulator
     *Why dont I create the main Win in CommModule itself ?
     *Might do that later, the reasoning now is that it will be easier for 
     *Simulator to detect if mainWindow has closed and do something  
     */
    
    public void setAppWindow(MainWindow m){
        mainWindow = m;
    }
//    public java.net.URL getBaseURL(){
//        
//        return sim.getDocumentBase ();
//        
//    }
    public String getVarDisplay(int node_num){
        return node[node_num].getVarDetails();
    }
    
    public Vector getFuncNames(int node_num){
        return node[node_num].getFuncNames(); 
    }

     public void invokeFunction(final SingleFunction f, final int node_num){
        System.out.println("Invoked Function " +f);
                class temp extends Thread { //new Thread( new Runnable { 
                    public void run(){
                        node[node_num].invokeFunction (f.w,f.h, f.func_num);
                        refreshGui();
                    }
            }
        temp t = new temp();
        t.start(); 
        
    }

    public void sendMessage (Message msg){
        if(!isEnabledNode(msg.getSrcId())) return;
        int sId = msg.getSrcId ();
        clock[sId].sendAction ();
         lc[sId].sendAction ();
        SingleEvent e;
        e = eventQueue.addSendEvent ('s',  msg, clock[sId], lc[sId].getValue (), sId);  
       
        channel.send (e , msg.getDestId());
    }    
    public void sendMessage (SlicingToken msg){

    }    
     public void recvMessage (SlicingToken t, final int destId){
         node[destId].recvdMessage(t);
     }
    public void recvMessage (SingleEvent e, final int destId){
        
        clock[destId].receiveAction (e.v.v);  
        lc[destId].receiveAction (e.nodeId, e.lc); 
 
        final SingleMessage m  = eventQueue.addReceiveEvent('r', e.msg, clock[destId], lc[destId].getValue (),destId,  e);// new SingleMessage (e,e1); 
//        msgQueue.add (m);
         class temp extends Thread { //new Thread( new Runnable { 
                    public void run(){
                        node[destId].recvdMessage (m);
                        
                    }
            }
        temp t = new temp();
        t.start(); 
        
        
        
    }
    

    
    void broadcast (Message msg) {
        if(!isEnabledNode(msg.getSrcId())) return;
        int sId = msg.getSrcId ();
        clock[sId].sendAction ();
        lc[sId].sendAction ();
        SingleEvent  e ;
        //= new SingleEvent ('b',getNextEventId(), msg, clock[sId],sId);
        e = eventQueue.addSendEvent ('b', msg, clock[sId],lc[sId].getValue (),sId);
        for (int i =0 ; i < num_nodes ;i+=1){
            if(sId != i) channel.send (e , i);
         }
 
    }    
    public void appendProcessLog(String se){
        mainWindow.appendProcessLog(se);        
    }
   public int getNodeColor(int node_num){
        return node[node_num].getNodeColor();
   
   }
   
    public  SingleEvent guiGetEvent(int i){
        return eventQueue.guiGetEvent(i);
      }
    public SingleMessage guiGetMessage(int i){
        return eventQueue.guiGetMessage (i);
     }
    public boolean pendingEvents(){
        return eventQueue.pendingEvents();
      }
        public int getLastMessageId(){
        return eventQueue.lastMessageId;
      }
    public java.util.List guiGetMessageQueue(){
        return eventQueue.myMessageQueue;
    }
    public int getSelectedNode(){
        return selectedNode;
    }
    public void setSelectedNode(int i){
        selectedNode = i;
    }
    
    public void disableNode(int i){
        enabledNode.set(i, new Boolean(false));
    }
      public void enableNode(int i){
        enabledNode.set(i, new Boolean(true));
    }
    public boolean isEnabledNode(int i){
        return ((Boolean)enabledNode.get(i)).booleanValue();
    }
    public void refreshGui(){
        mainWindow.refreshAll (); 
        
    }
    
    public void guiWaitForEvent(){
        eventQueue.guiWaitForEvent();
    }
    
}
